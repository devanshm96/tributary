Redis is way faster than a relational database, but not nearly as robust.

If you lose an engine temperature reading, it's no big deal; there'll be another one in a quarter second. The same cannot be said of credit card
data

Let's break it down:
At the top, we have a file format version indicator, which Docker Compose uses to parse the file.
After that, we have a services definition, which contains the tributary and redis services. Containers are articulated as services in Docker Compose. A service instantiates one or more replica containers of a single image.
Next comes a build tag, which indicates that the tributary image should be built locally using a Dockerfile at the specified path.
The Redis service has an image tag instead of a build tag. Docker will search its local image cache for a matching name before pulling the image from Dockerhub.
Finally, both containers have a ports definition.
These specify that the Docker engine should bind the host port on the left to the container port on the right. Doing so establishes a communication channel that the two can use to talk back and forth.
When a container is created, it is completely cut off from the outside world by default. To enable network traffic to and from a container, you must define which ports you'd like exposed to your host machine.
Our Flask server listens for incoming POST requests on port 8000, so we bind that to port 8000 on the host machine. Any network traffic directed to port 8000 on the host machine is transparently forwarded to port 8000 on the container, where your Flask server can interact with it.
Once you feel you understand the contents of the compose file, stand up the stack with docker compose up --build in your shell.
You should be met with some satisfying log messages reporting the existence of a Flask server and a Redis instance.
When you are finished looking at the logs, use ctrl + c to bring down the stack, just like before.